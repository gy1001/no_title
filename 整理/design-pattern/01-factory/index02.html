<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>简单工厂模式</title>
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"/>
</head>
<body>
（1）接口文件与继承文件的的引入  同上面

（2）静态工厂
</body>
<script type="text/javascript">
    // (1)定义一个接口类
    var Interface = function (name, methods) {
        if (arguments.length < 2) {
            alert('参数必须是两个');
            return
        }
        this.name = name;
        this.methods = [];　//定义一个空数组来装载函数名
        for (var i = 0; i < methods.length; i++) {
            if (typeof methods[i] !== 'string') {
                alert('函数名必须是字符串类型')
            } else {
                this.methods.push(methods[i])
            }
        }
    }

    Interface.ensureImplement = function (object) {
        if (arguments.length < 2) {
            throw new Error("参数必须不少于２个");
        }
        for (var i = 1; i < arguments.length; i++) {
            var inter = arguments[i];
            // 如果是接口就必须是interface类型
            if (inter.constructor !== Interface) {
                throw new Error("如果是接口类的话，就必须是Interface类型");
            }
            // 判断接口中的方法是否全部实现
            // 遍历函数集合
            for (var j = 0; j < inter.methods.length; j++) {
                var method = inter.methods[j]; //接口中所有函数
                // object[method]传入的函数
                // 最终是判断传入的函数是否与接口中所用的函数匹配
                if (!object[method] || typeof object[method] !== 'function') {
                    // 实现类必须有方法名字与接口中所用方法名相同
                    throw new Error('实现类中没有完全实现接口中的所有方法')
                }
            }
        }

    }

    // （2）继承文件
    // /*创建extend函数为了程序中所有的继承操作*/
    //subClass:子类  superClass：超类
    function extend(subClass, superClass) {
        // 1　使子类原型属性等于父类的原型属性
        // 初始化一个中间空对象，目的是为了转换主父关系
        var F = function () {}
        F.prototype = superClass.prototype;
        //让子类继承
        subClass.prototype = new F()
        subClass.prototype.constructor = subClass;
        // 3为子类增加属性　superClass => 原型链的引用
        subClass.superClass = superClass.prototype;
        //　４增加一个保险，就算你的原型类是超类（object）那么要是也把你的构造函数级别降下来
        if (superClass.prototype.constructor === Object.prototype.constructor) {
            superClass.prototype.constructor = superClass;
        }
    }

    //(2)接口调用
    var Pet=new Interface("Pet",["eat","run","sing","register"]);
    //（3）基类  分析后有共同的提出来作为基类
    function basePet() {
        this.register=function () {
            document.write("宠物登记。。。。<br>");
        }
        this.eat=function () {
            document.write("宠物吃饭。。。。<br>");
        }
    }
    //（4）实现类  继承基类+接口实现
    function Dog() {
        Dog.superClass.constructor.call(this);//继承父类
        //实现接口
        this.run=function () {
            document.write("小狗跑......<br>")
        }
        this.sing=function () {
            document.write("小狗唱歌......<br>")
        }
    }
    function Cat() {
        Cat.superClass.constructor.call(this);//继承父类
        //实现接口
        this.run=function () {
            document.write("小猫跑......<br>")
        }
        this.sing=function () {
            document.write("小猫唱歌......<br>")
        }
    }
    function Pig() {
        Pig.superClass.constructor.call(this);//继承父类
        //实现接口
        this.run=function () {
            document.write("小猪跑......<br>")
        }
        this.sing=function () {
            document.write("小猪唱歌......<br>")
        }
    }
    function Bird() {
        Bird.superClass.constructor.call(this);//继承父类
        //实现接口
        this.run=function () {
            document.write("小鸟跑......<br>")
        }
        this.sing=function () {
            document.write("小鸟唱歌......<br>")
        }
    }
    //继承
    extend(Dog,basePet);
    extend(Cat,basePet);
    extend(Pig,basePet);
    extend(Bird,basePet);


    //（1）使用工厂方式创建宠物对象
    // 静态工厂
    var factoryPet={
        //出售宠物的方法
        getPet:function (kind) {
            //宠物对象
            var pet;
            //宠物种类
            switch (kind){
                case  'dog':
                    pet=new Dog();
                    break;
                case  'cat':
                    pet=new Cat();
                    break;
                case  'pig':
                    pet=new Pig();
                    break;
                default:
                    pet=new Bird();
            }
            //验证接口
            Interface.ensureImplement(pet,Pet);//判断pet对象是否全部实行接口Pet里面全部的方法
            return pet;
        }
    }

    //（5）利用工厂的宠物店对象（宠物店买宠物）
    var factoryPetShop=function () {}
    factoryPetShop.prototype={
        getPet:function (kind) {
            var pet=factoryPet.getPet(kind);
            pet.eat();
            pet.register();
            return pet;
        }
    }
    //（6）从宠物店购买宠物
    var newPetShop=new factoryPetShop();//宠物工厂
    var flowerCat=newPetShop.getPet("cat");//从宠物工厂中得到宠物
    flowerCat.sing();
/*
总结一下，上述看似完美，但是任有问题存在：比如说：张三的宠物店想卖哈士奇，李四的宠物店想卖鸟时，
这样的话，宠物都是通过一个工厂生产的，并不一定满足各个卖家的需求。

所以我们需要根据各个厂家的需求，有不同的工厂，各个卖家可以根据自己需求使用不同的工厂
（其实是利用不同子类实现各自合适的工厂），用于满足每个宠物店的不同。

于是我们有了复杂的工厂用来解决该问题。


 */

</script>
</html>